#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\renewcommand{\contentsname}{Indice}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language italian
\language_package none
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 4cm
\rightmargin 4cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/immagini/logo.png
	display false
	scale 130

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/immagini/dipartimento.png
	display false
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\size largest
Corso di laurea Triennale in Informatica
\end_layout

\begin_layout Standard
\align left

\series bold
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\size larger
Tesi di Laurea
\end_layout

\begin_layout Standard
\paragraph_spacing double
\align center

\size huge
EmbASP, un framework per l'integrazione di moduli di ragionamento dichiarativo
 in sistemi esterni
\end_layout

\begin_layout Standard
\align left

\series bold
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
Relatore 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

Candidato
\end_layout

\begin_layout Standard
\align left
Prof.
 Francesco Calimeri 
\series bold

\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\series default
Marco Bellizzi
\end_layout

\begin_layout Standard
\align left

\series bold
Co-relatore
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\series default
Matricola 176239
\end_layout

\begin_layout Standard
\align left
Dott.
 Stefano Germano
\end_layout

\begin_layout Standard
\align left

\series bold
\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/immagini/firme.png
	display false
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center

\size largest
\bar under
Anno Accademico 2019/2020
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/immagini/ID-176239-Bellizzi Marco.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduzione
\end_layout

\begin_layout Standard
Potremmo identificare l’Intelligenza Artificiale come la disciplina che
 si occupa di realizzare macchine (hardware e software) in grado di “agire”
 autonomamente (risolvere problemi, compiere azioni, ecc.).
 L'avanzamento tecnologico e i risultati di ricerca hanno reso l'Intelligenza
 Artificiale (ormai nota con l’acronimo AI - Artificial Intelligence) una
 disciplina diffusa e di forte impatto anche sull'opinione pubblica.
 L’interesse della comunità scientifica per l’AI ha però origini molto lontane:
 il primo vero progetto di AI risale al 1943 quando i due ricercatori statuniten
si Warren McCulloch e Walter Pitts proposero al mondo scientifico il primo
 neurone artificiale.
 Ne seguì, nel 1949, il libro 
\begin_inset Quotes fld
\end_inset

L'organizzazione del comportamento
\begin_inset Quotes frd
\end_inset

 di Donald Olding Hebb, psicologo canadese, grazie al quale vennero analizzati
 in dettaglio i collegamenti tra i neuroni artificiali ed i modelli complessi
 del cervello umano.
 I primi prototipi funzionanti di reti neurali (cioè modelli matematici/informat
ici sviluppati per riprodurre il funzionamento dei neuroni biologici per
 risolvere problemi di Intelligenza Artificiale) arrivarono poi verso la
 fine degli anni ’50.
 L’interesse del pubblico si fece maggiore grazie soprattutto al giovane
 Alan Turing che già nel 1950 cercava di spiegare come un computer possa
 comportarsi come un essere umano.
 La sua formalizzazione dei concetti di algoritmo e calcolo mediante l'omonima
 
\begin_inset Quotes fld
\end_inset

macchina di Turing
\begin_inset Quotes frd
\end_inset

 da lui progettata, costiturono un significativo passo avanti nell'evoluzione
 verso il moderno computer, e per questo contributo è solitamente considerato
 il padre dell'Informatica e dell'Intelligenza Artificiale.
 Il termine Intelligenza Artificiale in realtà parte “ufficialmente” dal
 matematico statunitense John McCarthy, nel 1956, e con esso i primi linguaggi
 di programmazione (Lisp nel 1958 e Prolog nel 1973) specifici per l’AI.
 Da lì in poi la storia dell’Intelligenza Artificiale è stata abbastanza
 altalenante, caratterizzata da avanzate significative dal punto di vista
 dei modelli matematici ma con alti e bassi dal punto di vista della ricerca
 sull’hardware e sulle reti neurali.
 La prima grande svolta su quest’ultimo fronte è arrivata negli anni ’90
 con l’ingresso sul mercato “allargato” (arrivando cioè al grande pubblico)
 dei processori grafici, le Gpu (chip di elaborazione dati molto più veloci
 delle Cpu, provenienti dal mondo del gaming ed in grado di supportare processi
 complessi molto più rapidamente).
 L’ondata più recente è arrivata nell’ultimo decennio con lo sviluppo dei
 cosiddetti “chip neuromorfici”, ossia microchip che integrano elaborazione
 dati e storage in un unico micro componente per emulare le funzioni sensoriali
 e cognitive del cervello umano.
\end_layout

\begin_layout Standard
Lo sviluppo dell’Intelligenza Artificiale ha avuto molta influenza in diversi
 campi dell’Informatica, poichè la realizzazione dei sistemi di AI ha portato
 allo sviluppo di tecniche e strumenti innovativi.
 Questo è certamente il caso dei linguaggi di programmazione 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"
literal "false"

\end_inset

 : un campo nel quale molti linguaggi sono stati sviluppati inizialmente
 per rendere più efficiente la realizzazione di sistemi di AI.
 In particolare lo studio di metodi e tecniche per la rappresentazione della
 conoscenza ha portato alla realizzazione di ambienti basati sulla
\emph on
 logica
\emph default
, che offrono al programmatore la possibilità di sviluppare un sistema formalizz
ando nel linguaggio di rappresentazione le conoscenze sul dominio e offrendo
 strumenti per derivare le conseguenze delle conoscenze specificate.
 I linguaggi utilizzati per rappresentare la conoscenza sono detti linguaggi
 di programmazione dichiarativi, nel senso che consentono la specifica del
 problema, lasciando agli strumenti offerti dal sistema il compito di trovare
 algoritmicamente la soluzione.
\end_layout

\begin_layout Standard
I linguaggi di programmazione evoluti che sono stati introdotti a partire
 dagli anni ’50 sono detti linguaggi ad alto livello; essi sono stati progettati
 con lo scopo di rendere il linguaggio indipendente dalle caratteristiche
 dell’elaboratore e più vicino alla logica del programmatore.
 I programmmi scritti in un linguaggio ad alto livello non sono direttamente
 eseguibili dall’elaboratore, ma devono essere prima tradotti da un interprete
 o da un compilatore nel linguaggio macchina dell’elaboratore.
 Linguaggi di questo tipo sono anche detti linguaggi imperativi o anche
 linguaggi di Von Neumann, perchè fanno riferimento all’omonimo modello
 di calcolo.
 Essi fanno riferimento al modello di esecuzione delle istruzioni fornito
 dall’elaboratore: un programma è cioè costituito da una sequenza di istruzioni
 il cui effetto è quello di modificare il contenuto della memoria dell’elaborato
re.
 I linguaggi per l’AI appartengono ad altre categorie di linguaggi di programmaz
ione che prescindono dal modello di funzionamento dell’elaboratore, cercando
 di fornire un mezzo espressivo per specificare il compito da eseguire in
 modo semplice e sintetico.
 Questi tipi di linguaggi vengono anche detti non Von Neumann, proprio perchè
 sono svincolati dal modello su cui si basano i linguaggi imperativi, e
 fanno uso della 
\emph on
logica
\emph default
.
\end_layout

\begin_layout Subsection
Struttura della tesi
\end_layout

\begin_layout Standard
Lo scopo di questa tesi è la presentazione di EmbASP, un framework sviluppato
 dal dipartimento di Matematica e Informatica dell'Università della Calabria,
 che permette l'integrazione di moduli di ragionamento dichiarativo in sistemi
 esterni.
 Grazie ad esso è possibile creare applicazioni che contengono programmi
 logici al loro interno, facendo uso dei benefici che ciò comporta nella
 risoluzione di un problema complesso.
 Verranno esposti i principi fondamentali dei due linguaggi logici attualmente
 supportati da EmbASP (ASP e PDDL) e verrà esposto come viene fatta la loro
 integrazione nei tre linguaggi di programmazione in cui il framework è
 implementato (Java, Python e C#).
 La tesi è strutturata come segue:
\end_layout

\begin_layout Itemize
Nel Capitolo 2 esponiamo la programmazione ASP (Answer Set Programming),
 partendo dai principi base della programmazione logica.
 Esponiamo poi il linguaggio Prolog, che rappresenta le origini del linguaggio
 ASP.
 Analizziamo infine la semantica del liguaggio ASP e introduciamo la programmazi
one logica disgiuntiva e le principali estenzioni sintattiche.
\end_layout

\begin_layout Itemize
Nel Capitolo 3 esponiamo la programmazione PDDL (Planning Domain Definition
 Language), introducendo i problemi di pianificazione e presentando poi
 STRIPS, un linguaggio basato sulla logica in grado di affrontare tali problemi.
 Trattiamo poi come PDDL implementa STRIPS e come PDDL2.1 favorisce la pianificaz
ione con vincoli sulle risorse.
\end_layout

\begin_layout Itemize
Nel capitolo 4 presentiamo EmbASP.
 Ne analizziamo la struttura e le funzionalità che offre, e ne presentiamo
 degli esempi pratici del suo funzionamento.
\end_layout

\begin_layout Itemize
Nel capitolo 5 tratteremo le principali attività effettuate durante il periodo
 di tirocinio da me svolto presso il dipartimento di Matematica e Informatica
 dell'Università della Calabria, durante il quale ho avuto l'opportunità
 di collaborare con alcuni membri del dipartimento per contribuire all'evoluzion
e di EmbASP.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Programmazione ASP
\end_layout

\begin_layout Subsection
Introduzione alla programmazione logica
\end_layout

\begin_layout Standard
La logica (dal greco logos, ovvero “parola”, “pensiero”, “idea”) è uno strumento
 di espressione che trae origine dall’esigenza di formalizzare il ragionamento
 umano.
 La logica è tradizionalmente una delle discipline filosofiche, ma essa
 riguarda anche numerose attività tecniche e scientifiche, tra cui matematica,
 semantica e informatica.
\end_layout

\begin_layout Standard
Nella logica proposizionale esistono due valori (I cioè vero, e O cioè falso)
 e si basa su un insieme di proposizioni, e su un insieme di connettivi
 attraverso i quali è possibile combinare le proposizioni per creare formule
 arbitrariamente complesse 
\begin_inset CommandInset citation
LatexCommand cite
key "key-2"
literal "false"

\end_inset

 .
 Per proposizione intendiamo un’affermazione relativa ad un singolo fatto
 di cui può essere stabilita la verità.
 Il valore di verità di una formula ben formata può quindi variare a seconda
 di quanto stabilito dallo specifico assegnamento di verità utilizzato per
 le proposizioni presenti nella formula stessa.
\end_layout

\begin_layout Standard
Gli elementi sintattici di base della logica proposizionale sono i seguenti:
\end_layout

\begin_layout Itemize
Un insieme di proposizioni.
\end_layout

\begin_layout Itemize
Il seguente connettivo logico unario:
\end_layout

\begin_deeper
\begin_layout Itemize
Negazione: ¬
\end_layout

\end_deeper
\begin_layout Itemize
I seguenti connettivi logici binari:
\end_layout

\begin_deeper
\begin_layout Itemize
Disgiunzione: ∨
\end_layout

\begin_layout Itemize
Congiunzione: ∧
\end_layout

\begin_layout Itemize
Implicazione: → 
\end_layout

\begin_layout Itemize
Doppia implicazione: ↔
\end_layout

\end_deeper
\begin_layout Standard
La logica proposizionale non è, però, sufficientemente espressiva per rappresent
are ragionamenti relativi ad una moltitudine di oggetti, come “tutti gli
 oggetti godono di una certa proprietà” oppure “esiste almeno un oggetto
 che gode di una certa proprietà”.
 La logica proposizionale si concentra infatti sui connettivi logici e su
 come il valore di verità di una formula ben formata dipenda dal valore
 di verità delle sue sotto-formule immediate, senza considerare l’eventuale
 struttura interna delle proposizioni presenti nella formula.
 La logica dei predicati ovvia a questi inconvenienti includendo degli ulteriori
 operatori, detti quantificatori, in aggiunta ai connettivi logici della
 logica proposizionale e sostituendo le proposizioni con predicati (o atomi)
 applicati a termini.
 I termini, che individuano gli oggetti di interesse, sono espressi tramite
 costanti, variabili e funzioni definite sui termini.
 I predicati, che specificano le proprietà di interesse per gli oggetti
 precedentemente individuati, sono espressi tramite relazioni su insiemi
 di termini.
\end_layout

\begin_layout Standard
La logica dei predicati ha un quantificatore universale denotato con ∀ (“per
 ogni”) ed un quantificatore esistenziale denotato con ∃ (“esiste”), i quali
 possono fare riferimento solo a termini variabili che compaiono come argomenti
 di funzioni e predicati.
\end_layout

\begin_layout Standard
La programmazione logica nacque all’inizio degli anni ‘70 grazie soprattutto
 alle ricerche di due studiosi : Robert Kowalski ne elaborò i fondamenti
 teorici.
 In particolare a lui si deve la scoperta della doppia interpretazione,
 procedurale e dichiarativa, delle clausole di Horn; e Alain Colmeraurer,
 fu il primo a progettare e implementare un interprete per un linguaggio
 logico: il Prolog.
\end_layout

\begin_layout Standard
In programmazione logica un problema viene descritto con un insieme di formule
 della logica, dunque in forma dichiarativa.
 La programmazione classica, procedurale, è più adatta a problemi quotidiani,
 ben definiti.
 Essa adotta un paradigma imperativo: richiede cioè che siano specificate
 delle rigorose sequenze di passi (algoritmi) che, a partire dai dati a
 disposizione, portino ad ottenere i risultati desiderati.
 Nella programmazione logica i dati e il controllo sono ben distinti, bisogna
 preoccuparsi di specificare solo la componente logica mentre il controllo
 spetta al sistema.
 Ciò significa che bisogna solo definire il problema senza comunicare alla
 macchina come risolverlo.
 Nella programmazione logica si deve abbandonare il modo di pensare orientato
 al processo.
 Il programma è una descrizione della soluzione, non del processo, e si
 costruisce descrivendo in un linguaggio formale l'area applicativa, ossia
 gli oggetti che in essa esistono, le relazioni fra loro e i fatti che li
 riguardano.
 
\end_layout

\begin_layout Standard
Il linguaggio formale alla base della programmazione logica è rappresentato
 dalle clausole di Horn.
 Un letterale è un predicato, e viene definito positivo oppure negativo
 a seconda che sia della forma p oppure ¬p, con p una proposizione.
 Una clausola è una disgiunzione di letterali.
 Chiamiamo clausola di Horn una clausola che contiene al più un letterale
 positivo, la quale viene classificata come:
\end_layout

\begin_layout Itemize
Un fatto se è della forma p, che è equivalente a I → p.
\end_layout

\begin_layout Itemize
Un vincolo se è della forma 
\begin_inset Formula $\left(\bigvee_{i=1}^{n}¬p_{i}\right)$
\end_inset

, che è equivalente a 
\begin_inset Formula $\left(\bigwedge_{i=1}^{n}p_{i}\right)$
\end_inset

 → O.
\end_layout

\begin_layout Itemize
Una regola se è della forma p ∨ 
\begin_inset Formula $\left(\bigvee_{i=1}^{n}\neg p_{i}\right)$
\end_inset

, che è equivalente a 
\begin_inset Formula $\left(\bigwedge_{i=1}^{n}p_{i}\right)$
\end_inset

 → p.
\end_layout

\begin_layout Subsection
Prolog
\end_layout

\begin_layout Standard
Nato nel 1972 grazie alle ricerche di Alain Colmerauer e Robert Kowalski,
 il Prolog (acronimo per PROgramming in LOGic) è uno dei primi linguaggi
 di programmazione logica 
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"
literal "false"

\end_inset

 .
 E' molto potente e flessibile, ed è adatto particolarmente all'Intelligenza
 Artificiale.
 Il programmatore pone la sua attenzione sugli oggetti e sulle relazioni
 che li legano, esprimendo la conoscenza ad essi relativa sotto forma di
 fatti e di regole, per poi poter porre domande.
 L'interprete Prolog tenta poi di rispondere alle domande ponendole in relazione
 con i fatti e le regole della base di conoscenza.
\end_layout

\begin_layout Standard
Dunque, le componenti fondamentali del Prolog sono:
\end_layout

\begin_layout Itemize
Dichiarazioni di fatti sugli oggetti e le loro relazioni
\end_layout

\begin_layout Itemize
Dichiarazioni di regole sugli oggetti e le loro relazioni
\end_layout

\begin_layout Itemize
Domande sugli oggetti e le loro relazioni.
\end_layout

\begin_layout Standard
Tramite esse il programmatore interagisce col linguaggio: con le prime due
 scrive i programmi, con l'ultima li esegue.
 Programmare in Prolog equivale a descrivere il dominio del problema tramite
 fatti e regole sotto forma di clausole di Horn.
 Un predicato (o atomo) ha forma p(t
\begin_inset Formula $_{1}$
\end_inset

, ...
 , t
\begin_inset Formula $_{n}$
\end_inset

) dove p è il nome del predicato, t
\begin_inset Formula $_{1}$
\end_inset

, ...
 , t
\begin_inset Formula $_{n}$
\end_inset

 sono i termini e n (>= 0) è l’arietà del predicato.
\end_layout

\begin_layout Standard
I fatti Prolog sono predicati rappresentanti clausole di Horn non condizionali.
 Essi, cioè, esprimono un'affermazione che non è vincolata alla preventiva
 verifica di un insieme di condizioni.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

persona(marco).
 → marco è una persona
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Una relazione è, in genere, definita come l'insieme di tutte le sue istanze.
 Il Prolog tratta ogni relazione come una pura entità sintattica.
 Ciò vuol dire che il significato di una relazione è dato dal programmatore
 (intendendo con ciò l’ordine degli argomenti, il modo in cui vengono messi
 in relazione, il nome), ed è a suo carico usarla sempre in modo coerente
 con tale significato.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

genitore(stefano, marco) → stefano è genitore di marco
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Le regole Prolog sono clausole di Horn condizionali, cioè esprimono un'affermazi
one che è vincolata alla preventiva verifica di un insieme di condizioni.
 Un fatto è una cosa sempre, incondizionatamente, vera; una regola specifica
 una cosa vera a patto che la condizione sia soddisfatta.
 L’uso dei quantificatori (∀, ∃) viene espresso dall’uso delle variabili
 nelle regole.
 Le regole indicano situazioni di carattere generale servendosi di oggetti
 e relazioni tra essi.
 Una regola è costituita da una parte condizione (corpo, a destra) e una
 parte conclusione (testa, a sinistra), separate dal simbolo :- ("Se", che
 rappresenta l'implicazione).
 Una regola si dice safe se ogni variabile che appare in testa, in un letterale
 negativo o in un’operazione di comparazione (<, >, <=, …) appare anche
 in un letterale positivo.
 In un programma logico sono ammesse solo regole safe.
 In un contesto guidato dagli obiettivi come quello del Prolog, ogni regola
 di un programma si presta ad una duplice interpretazione.
 Il significato dichiarativo della regola è che la formula di testa è vera
 se la formula del corpo è vera.
 Il significato procedurale della regola è che per raggiungere l’obiettivo
 della formula di testa bisogna prima raggiungere l’ obiettivo della formula
 del corpo.
 Si distinguono perciò due tipi di predicati: i predicati EDB appaiono solo
 nel corpo delle regole o nei fatti, mentre i predicati IDB appaiono anche
 nella testa di qualche regola.
 Un programma Prolog parte con i fatti rappresentanti predicati EDB e iterativam
ente deriva i predicati IDB attraverso le regole.
 L’insieme dei fatti e delle regole costituisce la base di conoscenza.
 Una regola si definisce ricorsiva se tra i predicati nel corpo è presente
 il predicato in testa.
 La ricorsione è tipicamente usata nella programmazione logica per ottenere
 la chiusura transitiva di una relazione.
 La chiusura transitiva di una relazione R è un'altra relazione che aggiunge
 ad R tutti quegli elementi che, pur non essendo in relazione direttamente
 fra loro, possono essere raggiunti da una "catena" di elementi tra loro
 in relazione.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\align left
antenato(X,Y) :- genitore(X,Y).
 → se X è genitore di Y allora X è antenato di Y
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

antenato(X,Y) :- genitore(X,Z), antenato(Z,Y).
 → chiusura transitiva
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Il primo passo, nella programmazione Prolog, consiste nella creazione della
 base di conoscenza tramite un apposito ambiente di editing.
 Successivamente sarà possibile interrogarla in quello che viene chiamato
 ambiente di query.
 Nell’ambiente di query il Prolog avverte che è pronto a rispondere a delle
 eventuali domande riguardanti la base di conoscenza in suo possesso.
 Tali domande, in Prolog, vanno sotto il nome di goal (ossia obiettivi da
 dimostrare) o query (ossia interrogazioni da soddisfare).
\end_layout

\begin_layout Standard
Per risolvere problemi definiti attraverso clausole di Horn, il Prolog impiega
 il metodo di risoluzione di Robinson basato sulla strategia SLD 
\begin_inset CommandInset citation
LatexCommand cite
key "key-2"
literal "false"

\end_inset

 .
 L’esecuzione di un programma Prolog viene attivata da un obiettivo.
 L’obiettivo è una clausola di Horn data da un vincolo ed è descritto sintattica
mente come una regola senza testa in cui il simbolo :- è sostituito dal
 simbolo ?- .
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

?- antenato(francesco, marco).
 → francesco è un antenato di marco?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Il raggiungimento dell’obiettivo viene perseguito applicando il metodo di
 risoluzione basato sulla strategia SLD ai fatti e alle regole del programma
 e all’obiettivo dato.
 Dati un programma Prolog ed un obiettivo, bisogna trovare per tutti i predicati
 nell’obiettivo considerato, dei fatti che siano unificabili con quei predicati
 o delle regole le cui teste siano unificabili con quei predicati.
 Nel caso la risoluzione avvenga con una regola, bisogna poi procedere nello
 stesso modo con i predicati del corpo della regola considerati da sinistra
 a destra, seguendo l’ordine LIFO per coerenza con la strategia SLD.
 Per motivi di efficienza, conviene che le regole ricorsive siano ricorsive
 a destra, cioè che il predicato in testa di tali regole compaia nei predicati
 più a destra del corpo delle regole.
 Poiché ogni predicato presente in un obiettivo potrebbe essere unificabile
 con più fatti e teste di regole di un programma, in Prolog la risoluzione
 dei predicati viene esaminata rispetto a tutte le regole del programma,
 considerate nell’ordine in cui sono state scritte.
 Perciò, per motivi di efficienza, nei programmi conviene elencare i fatti
 prima delle regole.
 Posta una domanda, il Prolog risponde Yes o No per confermarne o meno la
 validità all'interno della base di conoscenza e, nel caso in cui la domanda
 contenga una variabile, Prolog risponde anche (se la risposta è affermativa)
 per quali oggetti la domanda è soddisfatta.
\end_layout

\begin_layout Standard
L’esecuzione di un programma Prolog su un obiettivo può essere rappresentata
 graficamente tramite un albero e-o, così chiamato perché ogni nodo rappresenta
 un obiettivo (congiunzione) e ha tanti nodi figli quanti sono i fatti e
 le regole alternativi tra loro con i quali può avvenire la risoluzione
 (disgiunzione).
 Durante l’applicazione della risoluzione, l’albero viene costruito in profondit
à per via dell’ordine LIFO imposto dalla strategia SLD.
\end_layout

\begin_layout Standard
La radice dell’albero e-o contiene l’obiettivo iniziale, mentre ogni foglia
 può contenere # oppure un obiettivo al cui predicato più a sinistra non
 è applicabile la risoluzione.
 Ogni ramo dell’albero è etichettato con i legami creati per unificazione
 durante la corrispondente applicazione della regola di risoluzione.
 Ogni cammino dalla radice ad una foglia contenente # è un cammino di successo,
 mentre tutti gli altri cammini sono cammini di fallimento o cammini infiniti.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Consideriamo il seguente programma Prolog:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

genitore(francesco, stefano).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

genitore(stefano, marco).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

antenato(X, Y) :- genitore(X, Y).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

antenato(X, Y) :- genitore(X, Z), antenato(Z, Y).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Consideriamo poi l’obiettivo:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

?- antenato(X, marco).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Osserviamo che l’obiettivo contiene una variabile, dunque l’esecuzione del
 programma consiste nel trovare tutti gli antenati della persona specificata,
 sulla base delle informazioni fornite dal programma.
 La risposta del Prolog sarà:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

antenato(stefano,marco).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

antenato(francesco,marco).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

e l’albero e-o risultante è il seguente:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/rhode/Immagini/albero.png
	display false
	scale 60

\end_inset


\end_layout

\begin_layout Subsection
Semantica ASP
\end_layout

\begin_layout Standard
Nel paragrafo precedente abbiamo brevemente descritto il metodo di risoluzione
 SLD adottato nella realizzazione di interpreti Prolog reali.
 Ciò che in pratica abbiamo fornito è una semantica operazionale della programma
zione logica 
\begin_inset CommandInset citation
LatexCommand cite
key "key-4"
literal "false"

\end_inset

 .
 Ci si può chiedere a questo punto se esista un modo per descrivere il significa
to di un programma logico senza fare riferimento a particolari strategie
 o metodi di risoluzione.
 Questo paragrafo illustra l’Answer Set Programming (ASP), un approccio
 alternativo introdotto nel 1993, il quale si estende più in generale a
 tutta la programmazione dichiarativa.
 Questo stile di programmazione risulta sufficientemente espressivo da essere
 proficuamente utilizzabile in diversi contesti.
 
\end_layout

\begin_layout Standard
L’Answer Set Programming, si differenzia in molteplici punti dalla programmazion
e Prolog, pur ereditandone quasi interamente la sintassi fin qui introdotta.
 Ciò che differenzia i due approcci è, da un lato il modo in cui viene assegnata
 la semantica ad un programma, dall’altro la procedura impiegata per trovare
 le soluzioni.
 Vediamo in modo informale una serie di punti in cui i due approcci si differenz
iano:
\end_layout

\begin_layout Itemize
In una regola ASP l’ordine dei predicati non ha alcuna importanza.
 Ciò è in contrasto con le convenzioni adottate in Prolog.
 Abbiamo infatti visto come il comportamento dell’interprete Prolog sia
 fortemente influenzato dall’ordine in cui i predicati occorrono in una
 regola.
 In ASP quindi il corpo di una regola si può considerare come un vero e
 proprio insieme di letterali.
\end_layout

\begin_layout Itemize
In Prolog l’esecuzione di un goal avviene in modo top-down e goal-directed:
 a partire dal goal si procede utilizzando le clausole e costruendo una
 derivazione che porta alla soluzione/risposta.
 Contrariamente a ciò, solitamente un interprete per l’ASP opera bottom-up,
 partendo dai fatti si procede verso le conclusioni che portano alla soluzione.
\end_layout

\begin_layout Itemize
La procedura risolutiva solitamente implementata in Prolog (risoluzione
 SLD), con le sue particolari scelte relative alle regole di selezione di
 letterali e clausole, può causare la generazione di computazioni infinite
 (anche in assenza della negazione).
 Ciò non accade invece per i solver ASP.
\end_layout

\begin_layout Standard
Le differenze tra Prolog e ASP nascono essenzialmente dal modo in cui viene
 assegnata la semantica ai programmi.
 Possiamo dire che l’ASP sia una forma di programmazione dichiarativa in
 cui si fissa la semantica dei programmi.
 Per descrivere la semantica di un programma ASP dobbiamo prima introdurre
 la nozione di 
\emph on
Answer Set
\emph default
.
 Innanzitutto affrontiamo il caso più semplice dei programmi ground.
 Un termine (un predicato, una regola o un programma) è detto ground se
 non contiene nessuna variabile 
\begin_inset CommandInset citation
LatexCommand cite
key "key-5"
literal "false"

\end_inset

 .
 Dato un programma logico P, chiamiamo Universo di Herbrand (Up) l’insieme
 di tutte le costanti in P.
 Chiamiamo Base di Herbrand l’insieme di tutti i possibili predicati ground
 costruibili dai predicati in P con le costanti nell’Universo di Herbrand
 (considerando anche la negazione).
\end_layout

\begin_layout Standard
Un’interpretazione I è un insieme di predicati ground.
 Un letterale positivo è vero rispetto ad I se appartiene ad I, falso altrimenti
; mentre un letterale negativo è vero rispetto ad I se non appartiene ad
 I, falso altrimenti.
 Un’interpretazione I è un modello per P se, per ogni regola in P, la verità
 del corpo della regola implica la verità della testa.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

a :- b, c.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

c :- d.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

d.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Interpretazioni:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
I1 = {b, c, d}
\end_layout

\begin_layout Standard
I2 = {a, b, c, d}
\end_layout

\begin_layout Standard
I3 = {c, d}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Notiamo che I2 e I3 sono modelli, mentre I1 non lo è perché il corpo della
 prima regola è vero rispetto a I1 (b e c appartengono a I1) mentre la testa
 è falsa (a non appartiene a I1).
 
\end_layout

\begin_layout Standard
L’intersezione di tutti i possibili modelli è detto modello minimale.
 Dato un programma P e un interpretazione I, si definisce conseguenza immediata
 di I l’insieme di tutti i predicati che compaiono in testa a qualche regola
 in P di cui il corpo è vero rispetto ad I.
 Applicando questo metodo più volte ad un programma, nella prima iterazione
 si analizzano i corpi delle regole con i predicati nell’insieme di partenza
 (ovvero i fatti).
 Se un corpo risulta vero, si deriva la testa.
 L’insieme di tutte le teste così derivate si unisce poi all’insieme di
 partenza e verrà usato nell’iterazione successiva.
 Il processo termina quando non vengono più generati nuovi predicati.
 Questo processo prende il nome di Tp ed è usato per l’individuazione dei
 modelli minimali di un programma logico.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

a :- b.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

c :- d.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

e :- a.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Tp(0) = {b} → interpretazione di partenza (fatti)
\end_layout

\begin_layout Standard
Tp(1) = {a}.
 → viene derivato a
\end_layout

\begin_layout Standard
Tp(2) = {e}.
 → modello minimale = {b, a, e}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
In un programma positivo (ovvero che non contiene negazione in nessuna regola)
 e ground, si ha la certezza che il Tp raggiunga un punto fisso, riuscendo
 a trovare il modello minimale.
 In un programma positivo non ground, il Tp inizia con i predicati EDB e
 iterativamente deriva i predicati IDB.
 Se il programma contiene regole ricorsive, questo processo potrebbe anche
 non raggiungere un punto fisso, e continuare a generare nuovi predicati
 IDB all'infinito.
 Inoltre, in un programma non positivo, la negazione può causare problemi
 se unita alla ricorsione.
 Per escludere la negazione all'interno della ricorsione, i programmi devono
 essere stratificati.
 Per chiarire la stratificazione facciamo uso del grafo delle dipendenze.
 In questo grafo i nodi sono i predicati IDB e la presenza di un arco da
 un nodo a un nodo b è data dalla presenza di a nel corpo di una regola
 in cui b è in testa.
 Un arco a → b viene marcato (con il simbolo -) se a è un letterale negativo.
 Un programma si dice stratificato se il relativo grafo delle dipendenze
 non contiene cicli in cui appare un arco marcato.
\end_layout

\begin_layout Standard
Un’ interpretazione I si dice essere un 
\emph on
Answer Set
\emph default
 per un programma positivo P se è un modello minimale per P.
 Per i programmi non positivi bisogna considerare il programma ridotto.
 Dato un problema P e un’interpretazione I, P ridotto si ottiene cancellando
 tutte le regole con un letterale negativo falso rispetto ad I e cancellando
 tutti i letterali negativi nelle rimanenti regole.
 Un Answer Set di un programma generico P è un’interpretazione I tale che
 essa sia un Answer Set per P ridotto.
 Gli Answer Set sono anche chiamati modelli stabili.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

P = { a :- d, not b.
 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b :- not d.
 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

d.
 
\begin_inset space ~
\end_inset

}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

I = {a, d}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

P ridotto = {a :- d.
 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

d.}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Notiamo che nella prima regola viene rimosso not b perché è un letterale
 negativo e la seconda regola viene rimossa perché not d è un letterale
 falso rispetto a I.
 I è un Answer Set per P ridotto dunque lo è anche per P.
\end_layout

\begin_layout Subsection
Estensioni
\end_layout

\begin_layout Standard
Una importante estensione della programmazione logica è la programmazione
 logica disgiuntiva.
 Essa è un potente formalismo per la rappresentazione della conoscenza e
 il ragionamento di senso comune, che consente di formalizzare, in modo
 semplice e naturale, problemi complessi.
 La programmazione logica disgiuntiva permette di avere nelle teste delle
 regole una disgiunzione di predicati, con il significato che se il corpo
 è vero allora uno dei predicati presenti nella disgiunzione della testa
 sarà vero.
 Quello che ne risulta è un linguaggio la cui alta espressività ha importanti
 implicazioni pratiche, consentendo la modellazione di situazioni reali,
 quali la rappresentazione di conoscenza incompleta.
 Sintatticamente la disgiunzione è rappresentata dal simbolo | nella testa
 delle regole.
\end_layout

\begin_layout Standard
Nella programmazione logica disgiuntiva i vincoli non sono intesi come in
 Prolog, ovvero come obbiettivi da raggiungere, bensì come strumenti con
 cui selezionare gli Answer Set da scartare.
 I vincoli scartano gli Answer Set in cui sono verificati contemporaneamente
 tutti i predicati nel corpo del vincolo.
 Sintatticamente i vincoli si presentano come delle regole senza testa.
 
\end_layout

\begin_layout Standard
I programmi sono quindi un insieme di regole e vincoli.
 Le soluzioni del programma sono dati dagli Answer Set risultanti.
 Le regole disgiuntive generano gli Answer Set, i vincoli selezionano quelli
 da scartare.
 Questo approccio prende il nome di Guess and Check.
 La programmazione logica disgiuntiva secondo la semantica dei modelli stabili
 è anche conosciuta con il nome di Answer Set Programming (ASP).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

a | b | c :- d.
 → guess
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:- d, c.
 → check
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

d.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Answer Sets:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

A1 = {d, a}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

A2 = {d, b}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

A3 = {d, c} → inammissibile
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Notiamo che la regola disgiuntiva genera tre Answer Set, ma A3 risulta inammissi
bile in quanto viola il vincolo (d e c sono veri entrambi contemporaneamente).
 Gli Answer Set risultanti sono dunque A1 e A2.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Il linguaggio ASP fin qui introdotto può essere usato per risolvere problemi
 di ricerca complessi, ma non fornisce strumenti per affrontare problemi
 di ottimizzazione, ad esempio problemi in cui oltre a risolvere il problema
 di ricerca si desidera minimizzare o massimizzare una data funzione.
 Per rimediare a queste limitazioni sono stati introdotti i vincoli deboli.
 Nel linguaggio base, i vincoli rappresentano una condizione che deve essere
 soddisfatta affinché l’ Answer Set sia valido, e per questa ragione sono
 anche chiamati vincoli forti.
 I vincoli deboli, invece, permetto di esprimere una condizione preferibilmente
 da non violare, con lo scopo di preferire quegli Answer Set che minimizzano
 la violazione di questo tipo di vincoli.
 In aggiunta, può essere specificato un peso e un livello di priorità alla
 violazione del vincolo debole.
 In questo modo, ogni volta che un Answer Set viola un vincolo debole, gli
 viene aggiunto il relativo peso del vincolo al livello di priorità specificato,
 potendo così individuare l’ Answer Set ottimo.
 La prima preferenza viene fatta per livello.
 Partendo dal livello più alto, vengono scartati gli Answer Set che hanno
 riscontrato pesi sul livello corrente, mentre ce ne sono altri che invece
 non hanno riscontrato pesi su questo livello.
 Si passa poi al livello inferiore e si ripete l’operazione finché non si
 giunge al livello minimo, ovvero il livello per cui tutti gli Answer Set
 rimanenti hanno riscontrato almeno un peso.
 A questo punto viene preferito quello che minimizza la somma totale dei
 pesi su questo livello.
 L’aggiunta dei vincoli deboli permette di estendere l’approccio Guess and
 Check aggiungendo la parte di ottimizzazione, in una tecnica di programmazione
 che prende il nome di GCO (Guess/Check/Optimize), in cui la parte Guess
 definisce lo spazio di ricerca, la parte Check verifica l’ammissibilità
 delle soluzioni e la parte Optimize specifica i criteri di preferenza.
\end_layout

\begin_layout Standard
Sintatticamente i vincoli deboli si presentano come quelli forti in cui
 il simbolo :- è sostituito dal simbolo :~ , e il peso e il livello sono
 espressi in seguito al vincolo in accordo con la specifica sintassi (nell’
 esempio sottostante sarà usata la sintassi del solver DLV2 in cui in aggiunta
 alla coppia peso@livello vengono elencate le variabili per le quali si
 intende instanziare il vincolo 
\begin_inset CommandInset citation
LatexCommand cite
key "key-5"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
Un’altra importante estensione al linguaggio ASP è l’aggiunta delle funzioni
 aggregate.
 Ci sono alcune semplici proprietà, spesso richieste nei programmi, che
 non possono essere espresse in maniera naturale usando la sintassi ASP.
 Specialmente le proprietà che fanno uso degli operatori aritmetici richiedono
 una modellazione pesante usando esclusivamente la sintassi ASP di base.
 Osservazioni simili sono state fatte in contesti come la gestione dei database,
 nei quali è stato appunto aggiunto l’uso di funzioni aggregate, e quando
 l’uso della programmazione ASP si è diffusa largamente il bisogno di integrarvi
 le funzioni aggregate è apparso necessario.
 Si definisce un insieme simbolico di elementi attraverso i predicati e
 poi si chiama la funzione desiderata su quell’insieme.
 Le funzioni più comuni sono il conteggio (#count), la somma (#sum), il
 minimo (#min) e il massimo (#max).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

numero(1).
 numero(2).
 → fatti 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

scelgo(X) | nonScelgo(X) :- numero(X).
 → guess
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:- #count{ X : scelgo(X) } > 1.
 → check 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:~ nonScelgo(X).
 [X@X, X] → optimize
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Answer Set:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

A1 = { scelgo(1), scelgo(2) } → pesi [2:2] [1:1] → inammissibile 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

A2 = { scelgo(1), nonScelgo(2) } → pesi [2:2] [0:1] → secondo 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

A3 = { nonScelgo(1), scelgo(2) } → pesi [0:2] [1:1] → ottimo 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

A4 = { nonScelgo(1), nonScelgo(2) } → pesi [2:2] [2:1] → terzo
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Notiamo che A1 è inammissibile perché la funzione #count ritorna il valore
 2 e il vincolo forte viene violato.
 L’ Answer Set ottimo è A3 perché il livello minimo è il livello 1, a A2
 e A4 vengono scartati in quanto hanno dei pesi a livello 2.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esistono molte altre notevoli estenzioni del linguaggio ASP, presenti in
 varie pubblicazioni scientifiche internazionali.
 Per approfondimenti riguardo le più recenti estenzioni invito a consultare
 
\begin_inset CommandInset citation
LatexCommand cite
key "key-7"
literal "false"

\end_inset

 .
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Programmazione PDDL
\end_layout

\begin_layout Subsection
Introduzione ai problemi di pianificazione
\end_layout

\begin_layout Standard
La pianificazione rappresenta un’importante attività di problem solving
 ed è una componente particolarmente importante dell’Intelligenza Artificiale.
 Con questo termine si intende l’elaborazione di un piano di azione per
 raggiungere un determinato obiettivo 
\begin_inset CommandInset citation
LatexCommand cite
key "key-6"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Un problema di pianificazione è dunque un problema di ricerca di una sequenza
 di azioni che, rispettando i vincoli imposti dal problema, porti al raggiungime
nto di un obiettivo.
 Problemi di questo tipo si compongono di tre elementi: uno stato iniziale
 (la situazione di partenza), uno stato finale (la situazione in cui vorremmo
 arrivare, l’obiettivo da raggiungere) e un insieme di azioni che, quando
 applicate, provocano un cambiamento di stato.
\end_layout

\begin_layout Standard
Un’azione può essere o meno applicabile in un certo stato e, se applicata,
 ha delle conseguenze sugli elementi del dominio e porta in un altro stato.
 Gli stati, all’interno del problema, sono delle descrizioni del dominio
 in cui stiamo operando e ne rispettano i vincoli.
 Le azioni consistono in un insieme di precondizioni e in un insieme di
 effetti.
 Le prime sono dei vincoli che definiscono se una azione può essere applicata
 o meno in un certo stato, i secondi rappresentano il risultato dell’esecuzione
 di una azione in termini di cosa cambia all’interno del dominio.
 Risolvere un problema di pianificazione vuol dire chiedersi se esiste una
 sequenza ordinata di azioni che porti dallo stato iniziale a quello finale.
\end_layout

\begin_layout Standard
Per realizzare un piano, con il tempo si sono tentati principalmente due
 approcci: un approccio manuale e uno automatico.
 La pianificazione manuale prevede la costruzione del piano da parte di
 un operatore umano.
 Il risultato di una operazione di questo tipo dipende molto dalle capacità
 e dall’esperienza dell’operatore nell’ordinare i compiti rispettando i
 vincoli del problema.
 Naturalmente l’utilizzo di questo approccio risulta molto complesso e costoso
 in termini di tempo, ed è possibile solamente per problemi non particolarmente
 articolati, in cui il numero di variabili e di vincoli è piccolo, e per
 problemi riguardanti ambienti completamente deterministici e prevedibili.
 Inoltre, anche riuscendo a trovare un piano, è molto improbabile che esso
 sia ottimale, per via dell’enorme quantità di fattori di cui l’operatore
 deve tener conto.
\end_layout

\begin_layout Standard
La pianificazione automatica, al contrario, delega il compito di costruire
 il piano interamente al sistema intelligente.
 Questo approccio permette di risparmiare molto tempo rispetto a quello
 manuale e può garantire una soluzione ottima.
 Non si può però considerare come una tecnica perfetta.
 È possibile infatti che una soluzione trovata dal pianificatore automatico,
 non sia poi effettivamente applicabile in quanto il sistema può non essere
 a conoscenza di informazioni non fornitegli perché impossibili da esprimere.
 Inoltre, anche la pianificazione automatica può funzionare solamente con
 domini deterministici e prevedibili.
\end_layout

\begin_layout Standard
La pianificazione, così come descritta fino ad ora, è detta classica o proposizi
onale, ed è in grado di trattare problemi non particolarmente complessi,
 nei quali c’è la necessità di capire cosa fare e in quale ordine farlo,
 ma non c’è bisogno di tener conto di fattori che durante l’esecuzione di
 un piano possono variare, quali il tempo o il consumo di risorse.
 Quando si trattano problemi reali, tuttavia, si ha a che fare con ambienti
 molto dinamici e scarsamente prevedibili, di cui si ha spesso una conoscenza
 solo parziale e in cui c’è la possibilità che si verifichino, a tempo di
 esecuzione, degli inconvenienti inaspettati che possono andare a modificare
 il mondo, rendendo inconsistente il piano realizzato in precedenza.
\end_layout

\begin_layout Standard
Fino a qualche anno fa, per via delle limitate capacità tecnologiche, la
 ricerca sulla pianificazione si è limitata quasi esclusivamente a problemi
 di questo tipo.
 Negli ultimi anni, invece, ci si è avvicinati sempre più alla pianificazione
 di problemi realistici.
 Quando si ha a che fare con problemi reali complessi sorge la necessità
 di gestire anche elementi variabili.
 Ogni azione che deve essere eseguita, infatti, ha una durata temporale
 e consuma una determinata quantità di risorse.
 In questi casi, perciò, occorre effettuare una pianificazione che tenga
 conto di tali vincoli, associando ad ogni azione il corrispondente tempo
 necessario per eseguirla e la quantità di risorse consumate.
 Soluzioni a problemi di questo tipo devono dunque soddisfare, oltre ai
 vincoli proposizionali, anche i vincoli numerici riguardanti le risorse
 consumabili.
 Inoltre devono tener conto dei vincoli numerici di ordine temporale, i
 quali possono essere associati sia alla durata del piano in sè, sia allo
 stesso utilizzo delle risorse, in relazione alla loro disponibilità rinnovabile
/riutilizzabile o meno.
 Questi accenni lasciano intuire quanto la pianificazione con vincoli su
 risorse consumabili sia tutt’altro che banale e le ragioni per le quali
 essa sia stata affrontata solamente in un tempo recente.
\end_layout

\begin_layout Subsection
STRIPS - PDDL
\end_layout

\begin_layout Standard
A livello pratico, la pianificazione classica si può trattare come un problema
 di ricerca nello spazio degli stati.
 Per rappresentare un problema è ormai consuetudine utilizzare linguaggi
 STRIPS-like.
 STRIPS (Stanford Research Institute Problem Solver) è un linguaggio basato
 sulla logica proposizionale e sull’uso di predicati.
 Esso permette di rappresentare ogni stato attraverso l’insieme di predicati
 che sono validi in quel determinato stato.
 Le azioni sono invece rappresentate attraverso precondizioni ed effetti.
 Le precondizioni includono i predicati che devono essere veri affinché
 si possa applicare l’azione.
 Gli effetti sono invece le conseguenze dell’applicazione dell’azione, ossia
 le modifiche che un’azione comporta sul dominio.
 
\end_layout

\begin_layout Standard
STRIPS fa un’assunzione di mondo chiuso, cioè suppone che ogni fatto non
 espressamente indicato sia falso.
 Inoltre, mentre si effettua una operazione, si assume che nel mondo non
 succeda nient’altro.
 Per questa ragione negli effetti di una azione si specificano solamente
 i cambiamenti che essa comporta, mentre tutto il resto non è esplicitato.
 Questo è importante in quanto nella maggior parte degli ambienti in cui
 si utilizza STRIPS, c’è una grande quantità di fatti che non cambiano nel
 tempo.
 Specificare solamente ciò che si modifica, dunque, permette di evitare
 di dover ricopiare completamente l’intero modello del mondo ogni volta
 che si passa da uno stato ad un altro.
 Gli effetti di una azione sono indicati come due liste: una DELETE-LIST,
 che contiene tutte le clausole che devono essere rimosse (e quindi implicitamen
te rese false), e una ADD-LIST, che contiene tutte le clausole che non sono
 presenti nello stato corrente e devono essere aggiunte (rese vere).
\end_layout

\begin_layout Standard
Una volta definito il problema, il compito del pianificatore è verificare
 se esiste una sequenza di azioni che faccia passare dallo stato iniziale
 a quello finale, e in tal caso, dire qual è.
 Per fare ciò il sistema intelligente esamina lo spazio degli stati, simulando,
 in ogni stato, l’applicazione di tutte le azioni applicabili (quelle le
 cui precondizioni sono soddisfatte), fino ad ottenere lo stato finale.
\end_layout

\begin_layout Standard
Intorno agli anni 2000, in seguito alle prime due edizioni dell’ International
 Planning Competition (IPC), si è affermato all’interno della comunità internazi
onale, come linguaggio standard per la rappresentazione di domini, PDDL,
 un linguaggio sviluppato da Drew McDermott e da alcuni suoi colleghi.
 Attraverso tale standardizzazione si è cercato di incentivare il progresso
 nel campo della pianificazione, favorendo la comunicazione tra i vari gruppi
 di ricerca, lo scambio e la comparazione dei lavori da essi effettuati.
\end_layout

\begin_layout Standard
PDDL (Planning Domain Definition Language), è dunque un Linguaggio di Descrizion
e dei Domini di Pianificazione.
 Esso si ispira a STRIPS e alla formulazione dei problemi secondo la sua
 logica.
 In particolare PDDL contiene STRIPS, e i domini scritti in PDDL si possono
 scrivere in STRIPS.
 Ci sono comunque alcune differenze tra i due linguaggi.
 In PDDL gli effetti di una azione non sono esplicitamente divisi in ADD-LIST
 e DELETE-LIST ma gli effetti negativi sono indicati con una negazione e
 sono messi in congiunzione insieme a quelli positivi.
 
\end_layout

\begin_layout Standard
Lo sviluppo della pianificazione con vincoli di risorse è stato favorito,
 in particolare, dal rilascio di PDDL 2.1 il quale fornisce una notevole
 potenza di modellazione.
 Esso è infatti in grado di modellare classi di domini che richiedono una
 pianificazione dell’uso delle risorse e del tempo, tramite l’uso di fluenti
 numerici, permettendo di dividere, all’interno del problema, la parte predicati
va da quella numerica.
 Tra le principali qualità di PDDL vi è una divisione delle caratteristiche
 di un dominio da quelle dell’istanza di un problema.
 Esso permette, cioè, di dividere la descrizione di azioni dalla descrizione
 di oggetti specifici o di condizioni iniziali e finali.
 In questo modo è possibile utilizzare delle variabili per parametrizzare
 le azioni e ciò permette di riutilizzare un dominio con istanze di problemi
 diversi, favorendo un’analisi di scenari differenti applicati allo stesso
 dominio.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio (dominio):
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
(define (domain blocks)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:requirements :strips :typing :fluents)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:types block)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:predicates (on ?x - block ?y - block) (ontable ?x - block)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(clear ?x - block) (handempty) (holding ?x - block) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:functions (moves) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:action pick-up
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:parameters (?x - block)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:precondition (and (clear ?x) (ontable ?x) (handempty))
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:effect (and (not (ontable ?x)) (not (clear ?x))
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(not (handempty)) (holding ?x) (increase (moves) 1) ) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:action put-down
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:parameters (?x - block)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:precondition (holding ?x)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:effect (and (not (holding ?x)) (clear ?x) (handempty)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(ontable ?x) (increase (moves) 1) ) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:action stack 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:parameters (?x - block ?y - block)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:precondition (and (holding ?x) (clear ?y))
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:effect (and (not (holding ?x)) (not (clear ?y)) (clear ?x)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(handempty) (on ?x ?y) (increase (moves) 1) ) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:action unstack
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:parameters (?x - block ?y - block)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:precondition (and (on ?x ?y) (clear ?x) (handempty))
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

:effect (and (holding ?x) (clear ?y) (not (clear ?x)) 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(not (handempty)) (not (on ?x ?y)) (increase (moves) 1) ) ) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
In esso si può notare la descrizione delle azioni parametrizzate al fine
 di lasciare poi all’istanza del problema il compito di sostituire i parametri
 formali con dei parametri attuali.
 Un’ importante caratteristica di PDDL riguarda quindi la definizione dei
 tipi.
 I tipi dei parametri di una azione vengono specificati esplicitamente all’inter
no di :parameters in cui una variabile è indicata con il punto interrogativo
 e il suo tipo è preceduto dal simbolo - .
 Le stesse variabili definite nell’elenco degli argomenti, sono poi utilizzate
 nella descrizione delle precondizioni e degli effetti dell’azione.
 I nomi dei tipi devono essere dichiarati attraverso :types e se si intende
 usarli è anche necessario dichiararlo all’interno dei requisiti (:requirements
 :typing … ).
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esempio (problema):
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
(define (problem blocks-01)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:domain blocks) (:objects A B C D - block)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:init (clear A) (clear B) (clear C) (clear D) (ontable A)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(ontable B) (ontable C) (ontable D) (handempty) (= (moves) 0) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:goal (and (on D C) (on C B) (on B A) ) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(:metric minimize (moves)) )
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
In esso viene invece mostrata la descrizione di un problema molto semplice.
 In questo caso, si può notare come le descrizioni degli oggetti specifici,
 le condizioni iniziali e i goals, vengano indicate senza l’uso di parametri,
 in quanto stiamo configurando l’istanza di un problema.
\end_layout

\begin_layout Standard
Questi esempi sono espressi in una rappresentazione che è già propria di
 PDDL 2.1.
 Vengono già utilizzati, infatti, i fluenti numerici, e il loro uso va specifica
to all’interno dei requisiti (:requirements :fluents … ).
 Elementi di questo tipo sono molto importanti, soprattutto per quanto riguarda
 la pianificazione di problemi realistici, in quanto permettono di modellare
 risorse non binarie.
 Essi sono indicati separatamente dai predicati.
 All’interno della definizione di un dominio i predicati vengono specificati
 in :predicates, mentre le funzioni numeriche sono inserite in :functions.
 I predicati possono essere veri o falsi e il loro significato non è intrinseco,
 dipende invece dagli effetti che le azioni del dominio possono avere su
 di essi.
 Si possono distinguere a livello concettuale (a livello sintattico non
 ci sono differenze) predicati statici e predicati dinamici.
 I primi sono predicati che non vengono cambiati da nessuna azione e che
 quindi dipendono solamente dallo stato iniziale del problema.
 I secondi invece sono quei predicati il cui valore viene alterato dalle
 azioni.
 Le funzioni, invece, possono essere viste come dei predicati a cui è associato
 un valore numerico anziché un valore booleano.
 Anche per esse, in generale, valgono le stesse considerazioni fatte per
 i predicati.
 Sia i predicati che le funzioni possono essere utilizzati come vincoli
 all’interno delle precondizioni di una azione, e i loro valori possono
 essere alterati dagli effetti.
 I vincoli numerici possono essere costruiti, usando operatori aritmetici,
 a partire da espressioni numeriche primitive.
 
\end_layout

\begin_layout Standard
In PDDL 2.1, oltre ai fluenti numerici, è stata anche introdotta la possibilità
 di definire delle metriche.
 Esse permettono di specificare i criteri su cui un piano deve essere valutato.
 L’introduzione di tali vincoli è dovuta alla possibilità di utilizzare
 dei fluenti numerici.
 Essi permettono di chiedere al sistema che il piano generato, oltre ad
 essere consistente, minimizzi o massimizzi una certa espressione.
 Naturalmente l’espressione da minimizzare (o massimizzare) può essere molto
 complessa, ottenendola dalla combinazione di più funzioni.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
EmbASP
\end_layout

\begin_layout Subsection
Presentazione
\end_layout

\begin_layout Standard
EmbASP è un framework sviluppato dal Dipartimento di Matematica e Informatica
 dell’Università della Calabria che supporta l’integrazione di moduli di
 ragionamento dichiarativo in sistemi esterni.
 Grazie ad esso è possibile creare applicazioni che contengono programmi
 logici al loro interno, facendo uso dei benefici che ciò comporta nella
 risoluzione di un problema complesso.
 Questo permette di modellare il problema in maniera molto intuitiva, affidando
 il compito di risolverlo al sistema, e lasciando al programmatore il solo
 compito di formularlo.
 Problemi complessi che normalmente richiederebbero algoritmi di alto livello
 per essere risolti, possono così essere dichiarati e risolti in maniera
 semplice e naturale.
 L’integrazione dei moduli di ragionamento dichiarato avviene attraverso
 l’esecuzione di un solver, uno strumento informatico in grado di risolvere
 il problema logico.
 Dato in input il programma, il solver lo risolve e comunica in output la
 soluzione.
 EmbASP si occupa di creare l’input rappresentante il programma logico e
 trasformarlo in un formato in grado di essere passato al solver.
 Al termine della risoluzione EmbASP raccoglie l’output e lo modella in
 un formato con cui l'applicazione può interagire.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/immagini/attività.png
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Un framework è una struttura astratta in cui vengono definiti gli elementi
 che lo compongono e le relazioni tra di essi.
 EmbASP è stato implementato in 3 linguaggi di programmazione: Java, Python
 e C#.
 Implementare un framework significa fornire un'implementazione concreta
 delle classi astratte.
 L'insieme delle classi concrete eredita le relazioni definite dal framework
 e si ottiene in questo modo un insieme di classi concrete messe in relazione
 tra di loro.
 EmbASP supporta due linguaggi logici: ASP e PDDL, dei quali si è discusso
 nei capitoli 2 e 3.
 Il linguaggio ASP è supportato grazie ai solver DLV, DLV2, DLVHEX e clingo.
 Questi solver sono file in grado di essere eseguiti da un computer.
 Possono essere scaricati dalla relativa fonte di appartenenza ed essere
 eseguiti localmente dal proprio computer.
 Essi richiedono in input il programma logico, lo risolvono, e restituiscono
 in output la soluzione.
 Il linguaggio PDDL è supportato grazie al solver SPD (Solver.Planning.Domains).
 Esso usa un cloud server per l’esecuzione remota.
 Il problema viene generato localmente e inviato tramite internet ad un
 server che si occupa di risolverlo e restituire la soluzione.
\end_layout

\begin_layout Subsection
Struttura
\end_layout

\begin_layout Standard
EmbASP è diviso in 4 moduli: Base, Platform, Languages e Specializations.
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/diagrammi_delle_classi/png/abstract_architecture.png
	display false
	scale 30

\end_inset


\end_layout

\begin_layout Standard
Nel modulo Base sono presenti le classi che rappresentano i componenti fondament
ali del framework, e viene definito in che modo essi sono messi in relazione
 tra loro.
 Le classi in questo modulo hanno un alto livello di astrazione, cioè definiscon
o solo quali sono le funzionalità principali offerte dai singoli componenti,
 che sono implementati in modo più specifico nei moduli successivi.
 La classe Handler è il componente principale del framework in quanto gestisce
 l'intero processo.
 L’Handler colleziona le informazioni necessarie a creare l’input, fornitegli
 dall’applicazione attraverso la classe InputProgram.
 Attraverso la classe OptionDescriptor si possono specificare delle opzioni
 aggiuntive da cominucare al solver.
 Queste informazioni vengono poi passate alla classe Service che avvia l’esecuzi
one del solver e gli trasmette le informazioni.
 Terminata l’esecuzione, il Service riceve l’output dal solver e lo passa
 all’Handler.
 L'output viene poi modellato grazie alla classe Output o attraverso la
 classe Callback, in modo che l'applicazione possa analizzarlo e gestirlo
 secondo le proprie necessità.
\end_layout

\begin_layout Standard
Nel modulo Platform sono presenti le estensioni delle classi Handler e Service
 che gestiscono le piattaforme supportate da EmbASP: Desktop in tutte e
 tre le versioni e Android solo sulla versione Java.
 La classe DesktopHandler gestisce il DesktopService per l’esecuzione del
 solver su una piattaforma Desktop e, in modo simile, la classe AndroidHandler
 gestisce l’AndroidService sulla piattaforma Android.
\end_layout

\begin_layout Standard
Nel modulo Languages sono presenti le estensioni delle classi InputProgram
 e Output, le quali hanno lo scopo di gestire l’input e l’output dei differenti
 solver.
 Per il linguaggio ASP l’InputProgram è esteso dalla classe ASPInputProgram
 e l’Output è esteso dalla classe AnswerSets, composto da un insieme di
 AnswerSet.
 Mentre l’InputProgram del linguaggio PDDL è esteso dalla classe PDDLInputProgra
m e l’Output dalla classe Plan, composto da un insieme di Action.
 L’InputProgram permette la creazione dell’input del programma logico in
 3 modi: aggiungendo le informazioni sotto forma di stringhe, da essere
 poi passate direttamente al solver; creando uno o più file in cui sono
 contenute le informazioni e specificando gli indirizzi di tali file; oppure
 creare delle classi che rappresentano i predicati del programma logico
 e aggiungere all’input le loro istanze (oggetti).
 Questo procedimento è assistito dalla classe Mapper, specializzato nell’ASPMapp
er e nel PDDLMapper, e da ANTLR, uno strumento generatore di parser e traduttori
 che permette di definire grammatiche, di cui EmbASP fa uso.
 Le classi che intendono rappresentare predicati del programma logico devono
 essere arricchite con delle informazioni che il Mapper è in grado di elaborare,
 al fine di convertire gli oggetti in stringhe (in grado di essere passate
 al solver).
 Per effettuare ciò la versione Java usa le Java Annotation, una forma di
 meta-codice che marca le classi con delle informazioni che sono analizzate
 a tempo di esecuzione.
 Le classi che rappresentano un predicato specifico devono essere marcate
 con l’annotazione @Id(nome_del_predicato) e ogni parametro della classe
 deve essere annotato con @Param(posizione).
 Grazie alle Java Reflection le annotazioni vengono esaminate e gli oggetti
 vengono tradotti in stringe e passati al solver.
 Nella versione Python viene usata una classe astratta Predicate.
 Le classi che rappresentano i predicati devono estendere la classe Predicate.
 Devono contenere al loro interno un parametro di nome “predicate_name”,
 contenente una stringa rappresentante il nome del predicato, e una lista
 contenente il nome dei parametri che il predicato ha.
 Queste informazione sono poi usate dal Mapper per eseguire correttamente
 la conversione delle classi in stringhe.
 Nella versione C#, in modo simile alla versione Java, le classi che rappresenta
no i predicati vengono marcate attraverso i C# Attributes.
 La classe deve essere marcata con [Id(nome_del_predicato)] e i parametri
 con [Param(posizione)] per poter permettere al Mapper, con il supporto
 della C# Reflection, di eseguire la traduzione.
 
\end_layout

\begin_layout Standard
Nel modulo Specialization sono contenute le specifiche estensioni delle
 classi Service e Output, per poter gestire l’esecuzione dei differenti
 solver.
 Nello specifico, in tutte e tre le versioni sono contenute le estensioni
 della classe DesktopService per i differenti solver (DLVDesktopService,
 DLV2DesktopService, DLVHEXDesktopService, ClingoDesktopService e SPDDesktopServ
ice) mentre solo nella versione Java sono presenti le estensioni dell’ AndroidSe
rvice e solo per i solver DLV, DLV2 e SPD (DLVAndroidService, DLV2AndroidService
 e SPDAndroidService).
 Sono contenute anche le estensioni della classe AnswerSets per il linguaggio
 ASP (DLVAnswerSets, DLV2AnswerSets, DLVHEXAnswerSets e ClingoAnswerSets)
 e della classe Plan per il linguaggio PDDL (SPDPlan).
 
\end_layout

\begin_layout Subsection
Esempi
\end_layout

\begin_layout Standard
Di seguito sono mostrati due esempi del funzionamento di EmbASP.
 Nel primo esempio sarà risolto il problema del cammino minimo usando la
 programmazione ASP, usando la versione Java di EmbASP su una piattaforma
 Desktop e usando il solver DLV2.
 Il problema del cammino minimo è un problema in cui, dato un grafo orientato
 e pesato, bisogna riuscire a trovare il cammino, da un nodo sorgente a
 un nodo di destinazione, che minimizzi la somma dei pesi negli archi inclusi
 in tale cammino.
 In questo esempio, dato il grafo riportato di seguito, si vuole trovare
 il cammino minimo dal nodo 0 al nodo 7.
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/immagini/shortest-path.png
	display false
	scale 25

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Per effettuare ciò, sono state create due classi, rappresentati gli archi
 del grafo, che verranno poi usate come predicati del programma logico.
 La classe Edge rappresenta gli archi in input del programma logico, mentre
 la classe Path rappresenta gli archi inclusi nel cammino minimo.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,extendedchars=true,keywordstyle={\color{red}}"
inline false
status open

\begin_layout Plain Layout

@Id("edge") public class Edge {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 @Param(0) private int from;
\end_layout

\begin_layout Plain Layout

 @Param(1) private int to;
\end_layout

\begin_layout Plain Layout

 @Param(2) private int weight;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 public Edge(int from, int to, int weight) {
\end_layout

\begin_layout Plain Layout

  this.from = from;
\end_layout

\begin_layout Plain Layout

  this.to = to;
\end_layout

\begin_layout Plain Layout

  this.weight = weight;
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 [...]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Id("path") public class Path {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 @Param(0) private int from;
\end_layout

\begin_layout Plain Layout

 @Param(1) private int to;
\end_layout

\begin_layout Plain Layout

 @Param(2) private int weight;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 public Path(int from, int to, int weight) {
\end_layout

\begin_layout Plain Layout

  this.from = from; 
\end_layout

\begin_layout Plain Layout

  this.to = to;
\end_layout

\begin_layout Plain Layout

  this.weight = weight;
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 [...]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
A questo punto, supponendo di aver scaricato il solver DLV2 sul proprio
 computer e di averlo incluso nel progetto, possiamo sviluppare la nostra
 applicazione.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,showstringspaces=false,keywordstyle={\color{red}}"
inline false
status open

\begin_layout Plain Layout

public class ShortestPath {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 // nodo sorgente e di destinazione
\end_layout

\begin_layout Plain Layout

 private static int from = 0;
\end_layout

\begin_layout Plain Layout

 private static int to = 7;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 // archi nel cammino minimo (ordinati)
\end_layout

\begin_layout Plain Layout

 private static ArrayList<Integer> sortedPath; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

  try {
\end_layout

\begin_layout Plain Layout

   Handler handler = new DesktopHandler(
\end_layout

\begin_layout Plain Layout

    new DLV2DesktopService("executable/dlv2"));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   ASPMapper.getInstance().registerClass(Edge.class);
\end_layout

\begin_layout Plain Layout

   ASPMapper.getInstance().registerClass(Path.class);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   InputProgram input = new ASPInputProgram();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   String rules = "from(" + from + ").
 to(" + to + ")."
\end_layout

\begin_layout Plain Layout

    + "path(X,Y,W) | notPath(X,Y,W) :- from(X), edge(X,Y,W)."
\end_layout

\begin_layout Plain Layout

    + "path(X,Y,W) | notPath(X,Y,W) :- 
\end_layout

\begin_layout Plain Layout

      path(_,X,_), edge(X,Y,W), not to(X)."
\end_layout

\begin_layout Plain Layout

    + "visited(X) :- path(_,X,_)." 
\end_layout

\begin_layout Plain Layout

    + ":- to(X), not visited(X)."
\end_layout

\begin_layout Plain Layout

    + ":~ path(X,Y,W).
 [W@1 ,X,Y]";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   input.addProgram(rules); 
\end_layout

\begin_layout Plain Layout

   for(Edge edge : getEdges())
\end_layout

\begin_layout Plain Layout

    input.addObjectInput(edge);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   handler.addProgram(input);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   AnswerSets answerSets = (AnswerSets) handler.startSync();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   for(AnswerSet answerSet : answerSets.getOptimalAnswerSets()) { 
\end_layout

\begin_layout Plain Layout

    // archi nel cammino minimo (non ordinati)
\end_layout

\begin_layout Plain Layout

    ArrayList<Path> path = new ArrayList<Path>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    int sum = 0; // peso totale del cammino
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for(Object obj : answerSet.getAtoms()) {
\end_layout

\begin_layout Plain Layout

     if(obj instanceof Path) {
\end_layout

\begin_layout Plain Layout

      path.add((Path)obj);
\end_layout

\begin_layout Plain Layout

      sum += ((Path)obj).getWeight();
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    join(from,path,sortedPath); // ordina gli archi
\end_layout

\begin_layout Plain Layout

    print(sortedPath,sum); // mostra il cammino
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

  } catch (Exception e) { e.printStackTrace(); }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 private static ArrayList<Edge> getEdges() {
\end_layout

\begin_layout Plain Layout

  ArrayList<Edge> edges = new ArrayList<Edge>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(0,1,1));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(0,2,4));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(1,2,2));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(1,3,4));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(1,4,1));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(2,4,4));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(3,5,6));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(3,6,1));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(4,3,1));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(6,4,5));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(6,5,9));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(6,7,1));
\end_layout

\begin_layout Plain Layout

  edges.add(new Edge(7,5,2));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return edges;
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 [...]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
L’applicazione contiene un Handler, inizializzato con un DesktopHandler,
 che usa come parametro un DLV2DesktopService con una stringa che rappresenta
 il percorso in cui si trova il solver DLV2.
 La classe ASPMapper registra le classi Edge e Path precedentemente create,
 per poter poi effettuare la traduzione delle loro istanze in stringhe,
 e viceversa.
 E’ stato creato un InputProgram, inizializzato con un ASPInputProgram,
 e gli sono stati aggiunti una stringa e una lista di Edge, rappresentanti
 fatti, regole e vincoli del programma ASP.
 L’InputProgram è stato passato all’Handler, che ha poi avviato l’esecuzione
 del solver.
 L’output è stato raccolto nella classe AnswerSets, che poi è stata esaminata.
 Sono stati raccolti i Path, rappresentanti gli archi nel cammino minimo,
 e la somma dei loro pesi.
 Infine sono stati ordinati e visualizzati.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Il secondo esempio riguarda il problema blocks-world, ed è stato usato il
 linguaggio PDDL, usando l’implementazione in Python di EmbASP e usando
 il solver SPD.
 Blocks-world è un problema in cui dato un insieme di blocchi disposti in
 una configurazione iniziale, bisogna trovare una serie di passaggi attraverso
 i quali disporre i blocchi nella configurazione desiderata.
 In questo esempio, data la configurazione iniziale a sinistra, ovvero 4
 blocchi tutti separati tra loro, si vuole portarli nella configurazione
 finale a destra, ovvero uno sopra l’altro.
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/immagini/blocks-world.png
	display false
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Per fare questo sono state create delle classi rappresentanti le azioni
 che posso essere eseguite.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,showstringspaces=false,keywordstyle={\color{red}}"
inline false
status open

\begin_layout Plain Layout

class PickUp(Predicate):
\end_layout

\begin_layout Plain Layout

 predicateName="pick-up"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 def __init__(self, block=None):
\end_layout

\begin_layout Plain Layout

  super(PickUp, self).__init__([("block")])
\end_layout

\begin_layout Plain Layout

  self.block = block
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class PutDown (Predicate):
\end_layout

\begin_layout Plain Layout

 predicateName="put-down"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 def __init__(self, block=None):
\end_layout

\begin_layout Plain Layout

  super(PutDown, self).__init__([("block")])
\end_layout

\begin_layout Plain Layout

  self.block = block
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Stack (Predicate):
\end_layout

\begin_layout Plain Layout

 predicateName="stack"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 def __init__(self, block1=None, block2=None):
\end_layout

\begin_layout Plain Layout

  super(Stack, self).__init__([("block1"), ("block2")])
\end_layout

\begin_layout Plain Layout

  self.block1 = block1
\end_layout

\begin_layout Plain Layout

  self.block2 = block2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Unstack (Predicate):
\end_layout

\begin_layout Plain Layout

 predicateName="unstack"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 def __init__(self, block1=None, block2=None):
\end_layout

\begin_layout Plain Layout

  super(Unstack, self).__init__([("block1"), ("block2")])
\end_layout

\begin_layout Plain Layout

  self.block1 = block1
\end_layout

\begin_layout Plain Layout

  self.block2 = block2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 [...]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
A questo punto, supponendo che siano stati creati due file (domain.pddl e
 p01.pddl) contenenti le definizioni del dominio e del problema (il cui contenuto
 è discusso nell’esempio nel capito 2.2), si può iniziare a sviluppare l’
 applicazione.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,keywordstyle={\color{red}}"
inline false
status open

\begin_layout Plain Layout

handler = DesktopHandler(SPDDesktopService())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

input_domain = PDDLInputProgram(PDDLProgramType.DOMAIN)
\end_layout

\begin_layout Plain Layout

input_problem= PDDLInputProgram(PDDLProgramType.PROBLEM)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

input_domain.add_files_path("../domain.pddl")
\end_layout

\begin_layout Plain Layout

input_problem.add_files_path("../p01.pddl")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

handler.add_program(input_domain)
\end_layout

\begin_layout Plain Layout

handler.add_program(input_problem)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PDDLMapper.get_instance().register_class(PickUp)
\end_layout

\begin_layout Plain Layout

PDDLMapper.get_instance().register_class(PutDown)
\end_layout

\begin_layout Plain Layout

PDDLMapper.get_instance().register_class(Stack)
\end_layout

\begin_layout Plain Layout

PDDLMapper.get_instance().register_class(Unstack)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

output = handler.start_sync()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for obj in output.get_actions_objects():
\end_layout

\begin_layout Plain Layout

 if isinstance(obj, PickUp) | isinstance(obj, PutDown) |
\end_layout

\begin_layout Plain Layout

 isinstance(obj, Stack) | isinstance(obj, Unstack) :
\end_layout

\begin_layout Plain Layout

  print(obj)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Il file contiene un Handler, inizializzato con un DesktopHandler usando
 il parametro SPDDesktopService.
 Siccome PDDL richiede di definire separatamente il dominio e il problema,
 sono stati creati due PDDLInputProgram, uno di tipo domain e l’altro di
 tipo problem.
 Ad essi sono stati specificati gli indirizzi dei percorsi dei file precedenteme
nte creati, e poi sono stati passati all’Handler.
 La classe PDDLMapper registra le classi precedentemente create, per poter
 poi interagire con l’output del solver.
 L’handler ha avviato l’esecuzione del solver e l’output è stato ricevuto,
 esaminato e visualizzato.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Portare EmbASP in produzione
\end_layout

\begin_layout Standard
In questo paragrafo sono analizzate le attività effettuate durante il periodo
 di tirocinio da me svolto presso il Dipartimento di Matematica e Informatica
 dell'Università della Calabria.
 In questo periodo ho avuto l'opportunità di collaborare con alcuni membri
 del dipartimento, contribuendo alla crescita e allo sviluppo di EmbASP.
 Le attività effettuate riguardano la cura di tutti quegli aspetti pertinenti
 alla pubblicazione e al rilascio di un software.
 EmbASP è un progetto nato nel 2015, anno in cui è stata rilasciata la versione
 v1.0.0.
 Da allora sono state rilasicate varie versioni, in cui sono state aggiunte
 gradualmente varie funzionalita.
 Di seguito è riportato un elenco delle varie versioni, con una breve descrizion
e delle modifiche apportate e delle funzionalità aggiunte in ogni versione.
\end_layout

\begin_layout Itemize
v1.0.0 - Questa è la prima versione di EmbASP, una versione che supporta solo
 la programmazione ASP su una piattaforma Desktop, attraverso il solver
 DLV.
\end_layout

\begin_layout Itemize
v1.1.0 - Sono stati corretti alcuni piccoli problemi.
\end_layout

\begin_layout Itemize
v2.0.0 - È stato aggiunto il supporto alla piattaforma Android e il supporto
 al solver Clingo sulla piattaforma Desktop.
\end_layout

\begin_layout Itemize
v2.0.1 - Sono state aggiunte le Javadoc.
\end_layout

\begin_layout Itemize
v2.0.2 - È stata ristrutturata la classe Output, inserendo il parametro 'error'
 in cui sono riportati gli eventuali errori generati durante l'esecuzione
 del solver.
\end_layout

\begin_layout Itemize
v3.0.0 - È stato aggiunto il supporto al linguaggio PDDL aggiungendo il supporto
 al solver SPD sulle piattaforme Desktop e Android ed è stato aggiunto il
 supporto al sover DLV2 sulla piattaforma Desktop.
\end_layout

\begin_layout Itemize
v3.0.1 - Sono stati corretti alcuni errori nella piattaforma Android.
\end_layout

\begin_layout Itemize
v3.1.0 - Sono state rinominate le annotazioni 'Predicate' e 'Term' in 'Id'
 e 'Param'.
\end_layout

\begin_layout Itemize
v3.2.0 - È stato aggiornato il layout del progetto ed è stata aggiunta la
 libreria Json-simple.
\end_layout

\begin_layout Itemize
v4.0.0 - È stata aggiunta la versione in Python.
\end_layout

\begin_layout Itemize
v4.1.0 - È stata aggiornata la cartella contenente le risorse per i test,
 e sono state rinominate le classi e i metodi della versione Python seguendo
 la sintassi convenzionalmente usata in Python.
\end_layout

\begin_layout Itemize
v4.2.0 - È stato aggiunto il supporto alle costanti simboliche ASP nella versione
 Java e sono stati risolti alcuni problemi riguardanti la piattaforma Desktop.
\end_layout

\begin_layout Itemize
v4.3.0 - È stato aggiunto il supporto alle costanti simboliche ASP nella versione
 Python.
\end_layout

\begin_layout Itemize
v5.0.0 - È stata aggiunta la versione C#.
\end_layout

\begin_layout Itemize
v6.0.0 - È stato aggiunto il supporto al solver DLVHEX, è stato introdotto
 l'uso di ANTLR4 ed è stata rimossa la libreria Json-simple.
\end_layout

\begin_layout Subsection
Documentazione
\end_layout

\begin_layout Standard
Una delle attività più importanti in questo settore riguarda la creazione
 di una documentazione chiara e esaustiva del software, che sia in grado
 di spiegare all'utente la sua struttura e il suo funzionamento.
 EmbASP ha un sito internet, disponibile a questo indirizzo 
\begin_inset CommandInset href
LatexCommand href
name "https://www.mat.unical.it/calimeri/projects/embasp/"
target "https://www.mat.unical.it/calimeri/projects/embasp/"
literal "false"

\end_inset

, nel quale è presente la documentazione di cui EmbASP dispone.
 Una delle prime attività svolte è stata aggiornare la documentazione sul
 sito alla attuale versione di EmbASP.
 Questa attività comprende:
\end_layout

\begin_layout Itemize
Aggiornare la presentazione del framework.
\end_layout

\begin_layout Itemize
Aggiornare la descrizione dei moduli in cui EmbASP è diviso.
\end_layout

\begin_layout Itemize
Aggiornare le descrizioni e i diagrammi delle classi brevi delle versioni
 Java e Python.
\end_layout

\begin_layout Itemize
Creare e aggiungere una descrizione e il diagramma delle classi breve per
 la versione C#.
\end_layout

\begin_layout Itemize
Creare e aggiungere i diagrammi delle classi completi per tutte e tre le
 versioni, con descrizione dei parametri e dei metodi di ogni classe.
\end_layout

\begin_layout Itemize
Generare e aggiungere la documentazione Doxygen, uno strumento per la generazion
e della documentazione che estrae commenti dal codice sorgente e, in maniera
 automatica, genera file di tipo HTML.
\end_layout

\begin_layout Itemize
Creare e aggiungere un esempio (blocks-world) dell'uso di EmbASP su una
 piattaforma Desktop, usando il linguaggio PDDL nella versione C#.
\end_layout

\begin_layout Itemize
Creare e aggiungere un esempio (cammino minimo) dell'uso di EmbASP su una
 piattaforma Desktop, usando il linguaggio ASP in tutte e tre le versioni.
\end_layout

\begin_layout Itemize
Aggiornare la sezione Applications Showcase in cui è presente la descrizione
 di alcune applicazioni che fanno uso di EmbASP.
\end_layout

\begin_layout Standard
Per una documentazione più tecnica e dettagliata abbiamo deciso di usare
 il sito readthedocs.org.
 Questo sito permette di “allegare” ad EmbASP una documentazione scritta
 attraverso il linguaggio reStructuredText, un noto linguaggio di formattazione
 del testo.
 Attraverso Sphinx, un potente generatore di documentazione, readthedocs.org
 converte la documentazione allegata in formato HTML e ne permette la visualizza
zione.
 Ho provveduto a creare la documentazione di EmbASP attraverso il linguaggio
 reStructuredText e integrarla in readthedocs.org.
 La documentazione così generata è attualmente accessibile dal sito internet
 di EmbASP.
 La documentazione si divide in due parti: "documentazione" ed "esempi".
 Nella sezione "documentazione" troviamo una descrizione dettagliata delle
 3 implementazioni, con vari dettagli tecnici riguardanti il linguaggio
 e una descrizione più dettagliata riguardo le classi appartenenti al framework.
\end_layout

\begin_layout Standard
\align left
\begin_inset Graphics
	filename /home/rhode/Scrivania/Tirocinio/Documentazione/diagrammi_delle_classi/svg/class_diagram_java_v6.svg
	display false
	scale 37

\end_inset


\end_layout

\begin_layout Standard
Nella sezione "esempi" troviamo alcuni esempi pratici del funzionamento
 di EmbASP.
 Sono presenti un esempio per il linguaggio ASP per ognuna delle tre implementaz
ioni su una piattaforma Desktop (cammino-minimo), un esempio per il linguaggio
 PDDL per ognuna delle tre implementazioni su una piattaforma Desktop (blocks-wo
rld) e un esempio per la piattaforma Android per il linguaggio ASP solo
 nella implementazione Java.
 In tutta la documentazione, ogni classe presente può essere analizzata
 in dettaglio, grazie all'integrazione di Doxygen.
 Doxygen offre una visualizzazione in formato HTML della descrizione di
 ogni classe presente in EmbASP, analizzandone in dettaglio i campi e i
 metodi.
 Permette anche di visualizzare direttamente il codice sorgente, per ulteriori
 dettagli implementativi.
\end_layout

\begin_layout Standard
La documentazione creata offre quindi diversi gradi di dettaglio.
 Sul sito internet è presente solo l'architettura generale del framework,
 con una descrizione dei moduli in cui è diviso.
 Sul sito è presente il collegamento alla documentazione su readthedocs.org,
 nel quale troviamo una descrizione più dettagliata delle implementazioni
 e degli esempi del suo funzionamento.
 In esso troviamo anche la documentazione Doxygen in cui è presente una
 descrizione di ogni classe di ogni implementazione, e la possibilità di
 visualizzare direttamente il codice sorgente.
\end_layout

\begin_layout Subsection
Rilascio del software
\end_layout

\begin_layout Standard
Prima di effettuare il rilascio del software all'utente, occorre testarlo
 e assicurarsi che funzioni correttemente, che sia stabile e che non contenga
 bug o malfunzionamenti.
 Durante la fase di testing sono emersi alcuni problemi.
 Uno di questi riguarda una differenza tra il solver DLV2 e gli altri solver.
 Tutti gli altri solver offrono la possibilità di specificare l'input contempora
neamente sia tramite file che tramite STDIN, mentre il DLV2 no.
 L'input del solver DLV2 deve provenire o interamente da file esterni, o
 interamente da STDIN.
 EmbASP sfrutta la lettura da file quando l'utente specifica l'indirizzo
 di uno o più file contenenti l'input del solver, e sfrutta la lettura da
 STDIN quando l'utente genera dell'input attraverso stringhe o oggetti all'inter
no dell'applicazione, aggiungendo, in questo caso, la relativa opzione di
 lettura da STDIN del solver.
 Per ovviare a queste restrizioni, nelle versioni Java e C# era stato introdotto
 un meccanismo attraverso il quale l'input proveniente dall'applicazione
 veniva scritto in un file di testo creato appositamente e veniva specificato
 il percorso di tale file all'interno di EmbASP, usando in questo modo esclusiva
mente la lettura dell'input attraverso file.
 Mentre nella versione in Python questo problema non era stato gestito e
 il solver DLV2 ignorava semplicemente l'input proveniante da STDIN, in
 quanto, nella versione in Python, l'opzione di lettura da STDIN del solver
 veniva aggiunta di default, a prescindere dalla presenza di input proveniente
 dall'applicazione.
 La strategia che si è deciso di usare per ovviare a questo è di limitare
 EmbASP ad effettuare l'esecuzione del solver così come specificato dall'utente,
 e restituire un messaggio di errore nel caso in cui l'utente, usando il
 solver DLV2, effettua la lettura dell'input contemporaneamente da file
 e da STDIN.
 In questo modo si rende più stabile l'implementazione di EmbASP e più resilient
e rispetto a modifiche future dei solver.
 Ho provveduto a rimuovere l'uso del file temporaneo dalle versioni Java
 e C#, e a modificare la versione Python in modo che aggiunga l'opzione
 di lettura da STDIN del solver solo quando necessario, ovvero quando l'utente
 genera dell'input attraverso l'applicazione.
 In questo modo tutte le versioni non usano file temporanei, aggiungono
 l'opzione di lettura da input solo quando necessario e, riguardo il DLV2,
 se si prova a usare contemporaneamente la lettura dell'input da file e
 da STDIN viene riportato un errore, come desiderato.
 Funzionano invece correttemente utilizzando esclusivamente la lettura da
 file o la lettura da STDIN.
 Risolto questo problema, ho aggiunto ad ogni versione di EmbASP un test-case
 (cammino minimo) in cui viene testata l'esecuzione del solver DLV2.
\end_layout

\begin_layout Standard
Tutto il codice sorgente di EmbASP è depositato sul sito github.com, il noto
 servizio di hosting per progetti software.
 Tutto il codice era depositato in un unico repository, che era strutturato
 come segue:
\end_layout

\begin_layout Itemize
Java version - cartella contenente il codice sorgente della versione Java.
\end_layout

\begin_layout Itemize
Python version - cartella contenente il codice sorgente della versione Python.
\end_layout

\begin_layout Itemize
CSharp version - cartella contenente il codice sorgente della versione C#.
\end_layout

\begin_layout Itemize
test-resource - cartella contenente le risorse per i test di EmbASP.
\end_layout

\begin_layout Itemize
antlr-grammars - cartella contenente le risorse di cui ANTLR4 fa uso.
\end_layout

\begin_layout Standard
Per permettere di lavorare su una singola versione di EmbASP indipendentemente
 dalle altre, abbiamo provveduto a frammentare questo repository, depositando
 ogni componente in nuovo repository.
 I nuovi repository sono stati poi inclusi in quello principale attraverso
 i “Git Submodules”, uno strumento che permette di integrare un repository
 in un altro.
 In questo modo è possibile sia scaricare EmbASP interamente (ovvero il
 codice sorgente delle tre versioni e le risorse per i test e di ANTLR4),
 e sia scaricare singolarmente una specifica versione, nel caso in cui si
 avesse bisogno soltanto di quella.
 Da questa nuova struttura del repository è emerso però un inconveniente,
 ovvero che le modifiche apportante ai singoli componenti non venivano direttame
nte incluse nel repository principale.
 Per cercare di automatizzare l'aggiornamento dei submodules nel repository
 principale è stato introdotto il Dependabot, uno strumento in grado di
 controllare periodicamente lo stato dei submodules e, nel caso in cui in
 essi sono presenti degli aggiornamenti, il Dependabot invia una richiesta
 di aggiornamento nel repository principale.
\end_layout

\begin_layout Standard
Github, oltre ad offrire la possibilità di depositare il codice sorgente,
 permette anche di depositare le releases del software, attraverso un'interfacci
a appositamente dedicata.
 La versione Java di EmbASP è rilasciata al pubblico attravero un file JAR
 per la piattaforma Desktop e un file AAR per la piattaforma Android, la
 versione Python è rilasciata attraverso un file Wheel e la versione C#
 attraverso un file DLL.
 Questi file contengono sia il codice sorgente delle versioni di EmbASP,
 sia il codice sorgente di ANTLR4, quindi sono pronte per essere usate e
 non necessitano di nient'altro.
 Le releases, il codice sorgente e le risorse di EmbASP sono disponibile
 nel repository Github di EmbASP al seguente indirizzo 
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/DeMaCS-UNICAL/EmbASP"
target "https://github.com/DeMaCS-UNICAL/EmbASP"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Conclusioni
\end_layout

\begin_layout Standard
Attraverso questo elaborato si è voluto mettere in risalto come la logica
 abbia caratterizzato i linguaggi di programmazione per l'Intelligenza Artificia
le.
 Abbiamo visto come Prolog, uno dei primi linguaggi logici, tragga le sue
 origini dalla logica proposizionale e dalla logica dei predicati, in particolar
e dalla scoperta della doppia interpretazione della clausole di Horn.
 Abbiamo visto come dalle strutture logiche di base del Prolog sia derivata
 la attuale semantica ASP, e come essa sia particolarmente adatta nel campo
 dell'AI.
 Sono stati poi presentati i problemi di pianificazione, una componente
 importante dell'AI.
 Abbiamo visto come possono essere trattati attraverso il linguaggio PDDL
 e come anch'esso sia caratterizzato dall'uso della logica dei predicati.
\end_layout

\begin_layout Standard
È stato poi presentato EmbASP, un framework in grado di integrare programmi
 scritti nei linguaggi ASP e PDDL in applicazione esterne, sviluppate in
 linguaggi di programmazione ad oggetti.
 Grazie ad esso è possibile aggiungere una componente intelligente all'interno
 di applicazioni, facendo uso dei benefici che che la programmazione logica
 offre nella risoluzione di un problema complesso.
 Abbiamo esaminato la struttura di EmbASP, mettendo in luce come la risoluzione
 di un programma logico avvenga tramite l'esecuzione di un solver, e come
 EmbASP svolga una funzione di intermediazione tra l'applicazione e il solver.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Ringraziamenti
\end_layout

\begin_layout Standard
Desidero ringraziare tutti i docenti del corso di laurea in Informatica
 dell'Università della Calabria per tutto quello che mi hanno insegnato
 e per avermi fatto appassionare all'informatica, in particolar modo al
 professor Francesco Calimeri per avermi dato l'opportunità di collaborare
 con il team di EmbASP e redigere il presente elaborato di tesi.
\end_layout

\begin_layout Standard
Ringrazio il dottor Stefano Germano per l'enorme disponibilità dimostrata
 durante il periodo di tirocinio e per la sua costante presenza nello svolgiment
o delle attività, grazie al quale ho avuto modo di imparare tanto.
\end_layout

\begin_layout Standard
Ringrazio tutto il personale tecnico amministrativo del dipartimento di
 Matematica e Informatica dell'Univeristà della Calabria per il loro costante
 impegno di amministrazione, in particolar modo alla dottoressa Teresa Molinaro
 per la sua cortesia e la sua disponibilità a risolvere i miei non pochi
 problemi tecnici.
\end_layout

\begin_layout Standard
Ringrazio tutti gli amici e compagni di studio di informatica per essermi
 stati vicini in questi anni di studio, in particolar modo ad Artem e Ciccio
 per la loro grande amicizia, e MariaConcetta per la sua amicizia e per
 avermi incoraggiato e spronato a studiare sempre al meglio.
\end_layout

\begin_layout Standard
Il ringraziamento più grande va a tutta la mia famiglia che mi ha sempre
 sostenuto e incoraggiato, e senza la quale non ce l'avrei mai fatta.
 Un grazie speciale va a mia madre, mio padre, i miei fratelli e mia nonna.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"
literal "false"

\end_inset

 Daniele Nardi, Giorgio Grisetti (Università di Roma “La Sapienza”): Linguaggi
 per L'Intelligenza Artificiale.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"
literal "false"

\end_inset

 Marco Bernardo, Edoardo Bontà, Alessandro Aldini (Università degli Studi
 di Urbino “Carlo Bo”): Programmazione Procedurale e Logica.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"
literal "false"

\end_inset

 Stefano Ferilli (Università degli Studi di Bari): Programmazione Logica
 e Prolog
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"
literal "false"

\end_inset

 Agostino Dovier (Università di Udine): Programmazione Dichiarativa in Prolog,
 CLP e ASP
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"
literal "false"

\end_inset

 Nicola Leone (Università della Calabria): Disjunctive Logic Programming:
 Knowledge Representation Techniques, Systems, and Application.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"
literal "false"

\end_inset

Davide Dell'Anna (Università degli Studi di Torino): Un approccio mixed-initiati
ve per la pianificazione con vincoli su risorse consumabili
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-7"
literal "false"

\end_inset

 Francesco Calimeri, Giovambattista Ianni, Nicola Leone, Francesco Ricca
 (Università della Calabria), Wolfgang Faber (Institut für Angewandte Informatik
), Martin Gebser (Alpen-Adria-Universität), Roland Kaminski, Torsten Schaub
 (Institute of Computer Science, University of Potsdam), Thomas Krennwallner
 (XIMES GmbH): ASP-Core-2.03c
\end_layout

\end_body
\end_document
